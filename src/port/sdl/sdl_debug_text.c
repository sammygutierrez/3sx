#include "port/sdl/sdl_debug_text.h"
#include "sf33rd/AcrSDK/ps2/flps2etc.h"
#include "sf33rd/AcrSDK/ps2/foundaps2.h"
#include "structs.h"

#include <SDL3/SDL.h>

#if defined(DEBUG)

#define FONT_CHAR_WIDTH 8
#define FONT_CHAR_HEIGHT 8
#define FONT_ATLAS_COLS 16
#define FONT_ATLAS_WIDTH (FONT_ATLAS_COLS * FONT_CHAR_WIDTH)
#define FONT_ATLAS_HEIGHT (6 * FONT_CHAR_HEIGHT) // 96 chars / 16 cols = 6 rows

static SDL_Renderer* debug_renderer = NULL;
static SDL_Texture* font_texture = NULL;

// Simple 8x8 bitmap font data for ASCII characters 0x20-0x7F
static const unsigned char font_8x8[96][8] = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20 ' '
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00 }, // 0x21 '!'
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x22 '"'
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00 }, // 0x23 '#'
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00 }, // 0x24 '$'
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00 }, // 0x25 '%'
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00 }, // 0x26 '&'
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x27 '''
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00 }, // 0x28 '('
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00 }, // 0x29 ')'
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00 }, // 0x2A '*'
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00 }, // 0x2B '+'
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06 }, // 0x2C ','
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00 }, // 0x2D '-'
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00 }, // 0x2E '.'
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00 }, // 0x2F '/'
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00 }, // 0x30 '0'
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00 }, // 0x31 '1'
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00 }, // 0x32 '2'
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00 }, // 0x33 '3'
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00 }, // 0x34 '4'
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00 }, // 0x35 '5'
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00 }, // 0x36 '6'
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00 }, // 0x37 '7'
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00 }, // 0x38 '8'
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00 }, // 0x39 '9'
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00 }, // 0x3A ':'
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06 }, // 0x3B ';'
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00 }, // 0x3C '<'
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00 }, // 0x3D '='
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00 }, // 0x3E '>'
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00 }, // 0x3F '?'
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00 }, // 0x40 '@'
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00 }, // 0x41 'A'
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00 }, // 0x42 'B'
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00 }, // 0x43 'C'
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00 }, // 0x44 'D'
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00 }, // 0x45 'E'
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00 }, // 0x46 'F'
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00 }, // 0x47 'G'
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00 }, // 0x48 'H'
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, // 0x49 'I'
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00 }, // 0x4A 'J'
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00 }, // 0x4B 'K'
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00 }, // 0x4C 'L'
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00 }, // 0x4D 'M'
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00 }, // 0x4E 'N'
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00 }, // 0x4F 'O'
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00 }, // 0x50 'P'
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00 }, // 0x51 'Q'
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00 }, // 0x52 'R'
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00 }, // 0x53 'S'
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, // 0x54 'T'
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00 }, // 0x55 'U'
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 }, // 0x56 'V'
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00 }, // 0x57 'W'
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00 }, // 0x58 'X'
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00 }, // 0x59 'Y'
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00 }, // 0x5A 'Z'
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00 }, // 0x5B '['
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00 }, // 0x5C '\'
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00 }, // 0x5D ']'
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00 }, // 0x5E '^'
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF }, // 0x5F '_'
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60 '`'
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00 }, // 0x61 'a'
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00 }, // 0x62 'b'
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00 }, // 0x63 'c'
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00 }, // 0x64 'd'
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00 }, // 0x65 'e'
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00 }, // 0x66 'f'
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F }, // 0x67 'g'
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00 }, // 0x68 'h'
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, // 0x69 'i'
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E }, // 0x6A 'j'
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00 }, // 0x6B 'k'
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00 }, // 0x6C 'l'
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00 }, // 0x6D 'm'
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00 }, // 0x6E 'n'
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00 }, // 0x6F 'o'
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F }, // 0x70 'p'
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78 }, // 0x71 'q'
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00 }, // 0x72 'r'
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00 }, // 0x73 's'
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00 }, // 0x74 't'
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00 }, // 0x75 'u'
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00 }, // 0x76 'v'
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00 }, // 0x77 'w'
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00 }, // 0x78 'x'
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F }, // 0x79 'y'
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00 }, // 0x7A 'z'
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00 }, // 0x7B '{'
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00 }, // 0x7C '|'
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00 }, // 0x7D '}'
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x7E '~'
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x7F
};

// Create font atlas texture from bitmap font data
static bool create_font_atlas() {
    // Create a texture atlas for all 96 characters
    font_texture = SDL_CreateTexture(
        debug_renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, FONT_ATLAS_WIDTH, FONT_ATLAS_HEIGHT);
    if (font_texture == NULL) {
        return false;
    }

    // Enable texture blending
    SDL_SetTextureBlendMode(font_texture, SDL_BLENDMODE_BLEND);

    // Render to font texture
    SDL_SetRenderTarget(debug_renderer, font_texture);
    SDL_SetRenderDrawColor(debug_renderer, 0, 0, 0, 0);
    SDL_RenderClear(debug_renderer);

    // Draw all characters to the atlas
    SDL_SetRenderDrawColor(debug_renderer, 255, 255, 255, 255);
    for (int i = 0; i < 96; i++) {
        const unsigned char* glyph = font_8x8[i];
        int atlas_x = (i % FONT_ATLAS_COLS) * FONT_CHAR_WIDTH;
        int atlas_y = (i / FONT_ATLAS_COLS) * FONT_CHAR_HEIGHT;

        for (int row = 0; row < 8; row++) {
            unsigned char line = glyph[row];
            for (int col = 0; col < 8; col++) {
                if (line & (1 << col)) {
                    SDL_FRect pixel = {
                        .x = (float)(atlas_x + col), .y = (float)(atlas_y + row), .w = 1.0f, .h = 1.0f
                    };
                    SDL_RenderFillRect(debug_renderer, &pixel);
                }
            }
        }
    }

    // Reset render target to screen
    SDL_SetRenderTarget(debug_renderer, NULL);
    return true;
}

// Render a single character at the given position with the given color
static void render_char(char c, int x, int y, u8 r, u8 g, u8 b, u8 a) {
    int char_index = c - 0x20;
    int atlas_x = (char_index % FONT_ATLAS_COLS) * FONT_CHAR_WIDTH;
    int atlas_y = (char_index / FONT_ATLAS_COLS) * FONT_CHAR_HEIGHT;

    SDL_FRect src = { .x = (float)atlas_x, .y = (float)atlas_y, .w = FONT_CHAR_WIDTH, .h = FONT_CHAR_HEIGHT };
    SDL_FRect dst = { .x = (float)x, .y = (float)y, .w = FONT_CHAR_WIDTH, .h = FONT_CHAR_HEIGHT };

    SDL_SetTextureColorMod(font_texture, r, g, b);
    SDL_SetTextureAlphaMod(font_texture, a);
    SDL_RenderTexture(debug_renderer, font_texture, &src, &dst);
}

void SDLDebugText_Initialize(SDL_Renderer* renderer) {
    debug_renderer = renderer;
    if (debug_renderer != NULL) {
        create_font_atlas();
    }
}

void SDLDebugText_BeginFrame() {
    // Reset debug text buffer
    flDebugStrCtr = 0;
}

void SDLDebugText_Render() {
    if (debug_renderer == NULL) {
        return;
    }

    // Get the debug string buffer
    RenderBuffer* buff_ptr = (RenderBuffer*)flPS2GetSystemBuffAdrs(flDebugStrHan);
    if (buff_ptr == NULL || flDebugStrCtr == 0) {
        return;
    }

    // Set blend mode for text
    SDL_SetRenderDrawBlendMode(debug_renderer, SDL_BLENDMODE_BLEND);

    // First pass: Render black outline for all characters (8-direction)
    for (u32 i = 0; i < flDebugStrCtr; i++) {
        RenderBuffer* ch = &buff_ptr[i];
        if (ch->code < 0x20 || ch->code > 0x7F) {
            continue;
        }

        // Draw black outline in 8 directions for better readability
        render_char((char)ch->code, ch->x - 1, ch->y - 1, 0, 0, 0, 255); // top-left
        render_char((char)ch->code, ch->x, ch->y - 1, 0, 0, 0, 255);     // top
        render_char((char)ch->code, ch->x + 1, ch->y - 1, 0, 0, 0, 255); // top-right
        render_char((char)ch->code, ch->x - 1, ch->y, 0, 0, 0, 255);     // left
        render_char((char)ch->code, ch->x + 1, ch->y, 0, 0, 0, 255);     // right
        render_char((char)ch->code, ch->x - 1, ch->y + 1, 0, 0, 0, 255); // bottom-left
        render_char((char)ch->code, ch->x, ch->y + 1, 0, 0, 0, 255);     // bottom
        render_char((char)ch->code, ch->x + 1, ch->y + 1, 0, 0, 0, 255); // bottom-right
    }

    // Second pass: Render colored text on top
    for (u32 i = 0; i < flDebugStrCtr; i++) {
        RenderBuffer* ch = &buff_ptr[i];
        if (ch->code < 0x20 || ch->code > 0x7F) {
            continue;
        }

        // Extract color components (ARGB format)
        u8 a = (ch->col >> 24) & 0xFF;
        u8 r = (ch->col >> 16) & 0xFF;
        u8 g = (ch->col >> 8) & 0xFF;
        u8 b = ch->col & 0xFF;

        // The PS2 flPrintColor function halved all color values before storing them.
        // We need to double them back to restore the original brightness.
        // (see flPrintColor in flps2debug.c)
        r = (r < 128) ? r * 2 : 255;
        g = (g < 128) ? g * 2 : 255;
        b = (b < 128) ? b * 2 : 255;
        a = (a < 128) ? a * 2 : 255;

        // Render the character using bitmap font
        render_char((char)ch->code, ch->x, ch->y, r, g, b, a);
    }

    // Reset draw color
    SDL_SetRenderDrawColor(debug_renderer, 255, 255, 255, 255);
}

void SDLDebugText_Destroy() {
    if (font_texture != NULL) {
        SDL_DestroyTexture(font_texture);
        font_texture = NULL;
    }
    debug_renderer = NULL;
}

#else // !DEBUG

// Stub implementations for release builds
void SDLDebugText_Initialize(SDL_Renderer* renderer) {}

void SDLDebugText_BeginFrame() {}

void SDLDebugText_Render() {}

void SDLDebugText_Destroy() {}

#endif // DEBUG
